use crate::{
    common::*,
    error::ErrorHandler,
    scanner::{ExtractValue, Token},
};

use colored::*;
use logos::Lexer;
use std::collections::HashMap;
use std::mem::discriminant;

// Some helper macros to avoid repetition of code
// Expands to a match expression for any type keyword
macro_rules! token_type {
    () => {
        Token::TypeByte
            | Token::TypeFloat
            | Token::TypeNum
            | Token::TypeString
            | Token::TypeBool
            | Token::TypeDynamic
    };
}

// Expands to a match expression for any value/beginning of a lace expression */
macro_rules! token_value {
    () => {
        Token::Number(_)
            | Token::Hex(_)
            | Token::Float(_)
            | Token::String(_)
            | Token::FormattedString(_)
            | Token::Identifier(_)
            | Token::PrimitiveFnIdentifier(_)
            | Token::LeftSquare
            | Token::True
            | Token::False
            | Token::None
            | Token::KwTypeof
            | Token::OpBang
            | Token::OpSub
    };
}

/* Note: the type-checker is baked into the parser. */

pub struct Parser<'p> {
    // The lexer iterator generated by Logos
    source: Lexer<'p, Token>,

    // Index of the current token the parser is parsing
    current_i: usize,

    // The source code in text form, used for errors
    source_text: String,

    // The AST generated by the parser
    pub ast: Vec<Node>,

    // The current token the parser is parsing
    pub current: Token,
}

impl<'p> Parser<'p> {
    /*  Creates a new Parser.
        Requires for the lexer iterator to contain atleast one token, and will panic otherwise.
    */
    pub fn new(mut source: Lexer<Token>, source_text: String) -> Parser {
        let first = source.next().unwrap();

        Parser {
            source,
            current_i: 0,
            source_text,

            ast: vec![],
            current: first,
        }
    }

    fn advance(&mut self) -> Token {
        self.current_i += 1;

        match self.source.next() {
            Some(token) => {
                self.current = token.clone();
                token
            }
            None => {
                self.current = Token::End;
                Token::End
            }
        }
    }

    /* Helper function to get certain data to display an error message. */
    fn get_error_data(&mut self) -> (String, String, String, usize, &str) {
        let span = self.source.span();
        let mut line = 0;
        let lines: Vec<&str> = self.source_text.split('\n').collect();
        let mut last_n = 0;

        for (i, character) in self.source_text.char_indices() {
            if i == span.start {
                break;
            } else if character == '\n' {
                line += 1;
                last_n = i + 1;
            }
        }

        let line_len = line.to_string().len();

        (
            " ".repeat(line_len),
            " ".repeat(span.start - last_n),
            "^".repeat(span.end - span.start),
            line + 1,
            lines[line],
        )
    }

    fn error(&mut self, error: &str) -> ! {
        let (empty, spacing, pointer, line_idx, line_text) = self.get_error_data();
        ErrorHandler::error(empty, spacing, pointer, line_idx, line_text, error);
    }

    fn error_tip(&mut self, error: &str, tip: &str) -> ! {
        let (empty, spacing, pointer, line_idx, line_text) = self.get_error_data();
        ErrorHandler::error_tip(empty, spacing, pointer, line_idx, line_text, error, tip);
    }

    fn warn(&mut self, warning: &str) {
        println!("{}: {}", "Warning".bright_yellow(), warning);
    }

    // Advances the tokens iterator and checks if the current token is the token specified.
    fn expect(&mut self, token: Token, exact: bool) -> bool {
        let next = self.advance();
        (exact && next == token) || (!exact && discriminant(&next) == discriminant(&token))
    }

    // Raises an error if self.expect(token, exact) is false.
    fn expect_handle(&mut self, token: Token, exact: bool, error: &str) {
        if !self.expect(token, exact) {
            self.error(error);
        }
    }

    fn logical_expression(&mut self) -> Node {
        self.binary_expression("comparison", vec![Token::KwAnd, Token::KwOr])
    }

    fn comparison_expression(&mut self) -> Node {
        self.binary_expression(
            "additive",
            vec![
                Token::OpEq,
                Token::OpBangEq,
                Token::OpLess,
                Token::OpMore,
                Token::OpMoreEq,
                Token::OpLessEq,
            ],
        )
    }

    fn additive_expression(&mut self) -> Node {
        self.binary_expression("multiplicative", vec![Token::OpAdd, Token::OpSub])
    }

    fn multiplicative_expression(&mut self) -> Node {
        self.binary_expression(
            "unary",
            vec![
                Token::OpMul,
                Token::OpDiv,
                Token::OpMod,
                Token::OpPow,
                Token::OpLeftShift,
                Token::OpRightShift,
            ],
        )
    }

    fn value(&mut self) -> Node {
        let token = self.current.clone();
        self.advance();

        match &token {
            Token::Number(num) => Node::Value(Value::Number(*num)),
            Token::Hex(hex) => Node::Value(Value::Number(*hex)),
            Token::Float(num) => Node::Value(Value::Float(*num)),
            Token::String(str) => Node::Value(Value::String(str.trim_matches('"').to_string())),
            Token::FormattedString(str) => Node::Value(Value::FormattedString(str.to_string())),
            Token::Identifier(iden) => match self.current {
                Token::LeftParen => {
                    self.advance();
                    let mut arguments: Vec<Node> = vec![];

                    if !(self.current == Token::RightParen) {
                        arguments.push(self.expression());

                        while self.current == Token::Comma {
                            self.advance();

                            if !(self.current == Token::RightParen) {
                                arguments.push(self.expression());
                            }
                        }
                    }

                    self.advance();
                    Node::FunctionCall {
                        name: iden.to_string(),
                        arguments,
                    }
                }
                _ => Node::Value(Value::Identifier(iden.to_string())),
            },
            Token::PrimitiveFnIdentifier(iden) => match self.current {
                Token::LeftParen => {
                    self.advance();
                    let mut arguments: Vec<Node> = vec![];

                    if !(self.current == Token::RightParen) {
                        arguments.push(self.expression());

                        while self.current == Token::Comma {
                            self.advance();

                            if !(self.current == Token::RightParen) {
                                arguments.push(self.expression());
                            }
                        }
                    }

                    self.advance();
                    Node::PrimitiveFunctionCall {
                        name: iden.to_string(),
                        arguments,
                    }
                }
                _ => self.error("Expected '(' after primitive function call."),
            },
            Token::LeftSquare => {
                let mut elements: Vec<Node> = vec![];

                if !(self.current == Token::RightSquare) {
                    elements.push(self.expression());

                    while self.current == Token::Comma {
                        self.advance();

                        if !(self.current == Token::RightSquare) {
                            elements.push(self.expression());
                        }
                    }
                }

                self.advance();
                Node::Value(Value::NodeArray(elements))
            }

            Token::True => Node::Value(Value::True),
            Token::False => Node::Value(Value::False),
            Token::None => Node::Value(Value::None),

            e => self.error(&format!("Expected value, got {:?}.", e)),
        }
    }

    fn unary(&mut self) -> Node {
        match &self.current {
            Token::OpBang => {
                self.advance();
                Node::Unary(Box::new(self.unary()), UnaryOp::LogicalNot)
            }
            Token::OpSub => {
                self.advance();
                Node::Unary(Box::new(self.unary()), UnaryOp::Negate)
            }
            Token::KwTypeof => {
                self.advance();
                Node::Unary(Box::new(self.unary()), UnaryOp::Typeof)
            }
            _ => self.value(),
        }
    }

    fn from_builder(&mut self, builder: &str) -> Node {
        match builder {
            "unary" => self.unary(),
            "additive" => self.additive_expression(),
            "comparison" => self.comparison_expression(),
            "multiplicative" => self.multiplicative_expression(),
            _ => panic!("Unknown builder '{}'", builder),
        }
    }

    /* Helper function for parsing binary expression.
       `builder` -> the function you want to use to parse the left and right sides
       `operators` -> the operators you recognize on this precedence level
    */
    fn binary_expression(&mut self, builder: &str, operators: Vec<Token>) -> Node {
        let mut left = self.from_builder(builder);

        while operators.contains(&self.current) {
            let operator = self.current.clone();
            self.advance();

            let right = self.from_builder(builder);

            left = Node::Binary {
                left: Box::new(left),
                right: Box::new(right),
                operator,
            };
        }

        left
    }

    /* Parses a lace expression. Matches the current token and advances at the end. */
    #[inline(always)]
    fn expression(&mut self) -> Node {
        self.logical_expression()
    }

    fn parse_type(&mut self) -> Type {
        match self.current.clone() {
            token_type!() => {
                let srctype = match self.current.clone() {
                    Token::TypeByte => Type::Byte,
                    Token::TypeFloat => Type::Float,
                    Token::TypeNum => Type::Number,
                    Token::TypeString => Type::String,
                    Token::TypeBool => Type::Bool,
                    Token::TypeDynamic => Type::Dynamic,
                    _ => panic!(),
                };

                match self.advance() {
                    Token::LeftSquare => match self.advance() {
                        Token::RightSquare => {
                            self.advance();
                            let mut tpye = Type::Array(Box::new(srctype));

                            while self.current == Token::LeftSquare {
                                match self.advance() {
                                    Token::RightSquare => {
                                        self.advance();
                                        tpye = Type::Array(Box::new(tpye))
                                    }
                                    token_type!() => self.error_tip(
                                        "Expected ']' after array type.",
                                        "If you want to make nested arrays, try using this syntax: `type[][]`",
                                    ),
                                    _ => self.error("Expected ']' after array type."),
                                }
                            }

                            tpye
                        }
                        token_type!() => self.error_tip(
                            "Expected ']' after array type.",
                            "If you want to make nested arrays, try using this syntax: `type[][]`",
                        ),
                        _ => self.error("Expected ']' after array type."),
                    },
                    _ => srctype,
                }
            }
            _ => self.error("Expected type"),
        }
    }

    fn variable_decleration(&mut self, public: bool) -> Node {
        let is_mutable = match self.advance() {
            Token::KwMut => {
                self.expect_handle(
                    Token::Identifier(String::new()),
                    false,
                    "Expected identifier.",
                );
                true
            }
            Token::Identifier(_) => false,
            _ => self.error("Expected either `mut` or variable identifier."),
        };

        let name = self.current.extract();

        let annotation = match self.advance() {
            Token::Assign => self.error_tip(
                "Expected variable type.",
                "Use the `any` type if you want this variable to be dynamic.",
            ),
            Token::Colon => {
                self.advance();
                let annotation = self.parse_type();

                if !(self.current == Token::Assign) {
                    match self.current {
                        Token::OpEq => self.error_tip(
                            "Expected assignment '=' operator.",
                            "You're using a comparison operator. Perhaps try using `=`?",
                        ),
                        _ => self.error("Expected assignment '=' operator."),
                    }
                }

                annotation
            }
            Token::OpEq => self.error_tip(
                "Expected assignment '=' operator.",
                "You're using a comparison operator. Perhaps try using `=`?",
            ),
            _ => self.error("Expected either colon or assignment '=' operator."),
        };

        self.advance();
        let value = self.expression();

        if name.contains('_') {
            self.warn(&format!(
                "Variable `{}` should have a camelCase name.",
                name
            ))
        }

        Node::VariableDeclr {
            name,
            value: Box::new(value),
            public,
            annotation,
        }
    }

    fn variable_assignment(&mut self, name: String) -> Node {
        self.advance();
        let value = self.expression();

        Node::VariableAssignment {
            name,
            value: Box::new(value),
        }
    }

    fn return_statement(&mut self) -> Node {
        match self.advance() {
            token_value!() => Node::Return(Box::new(self.expression())),
            _ => Node::ReturnNone,
        }
    }

    fn while_statement(&mut self) -> Node {
        self.advance();
        let condition = self.expression();

        if self.current != Token::LeftCurly {
            self.error("Expected '{' after while statement.");
        }

        self.advance();
        let mut body: Vec<Node> = vec![];

        while self.current != Token::RightCurly {
            body.push(self.statement(false));
        }

        self.advance();

        Node::WhileLoop {
            condition: Box::new(condition),
            body,
        }
    }

    fn function_decleration(&mut self, public: bool) -> Node {
        let coroutine = match self.current {
            Token::KwFn => false,
            Token::KwAsync => true,
            _ => panic!(),
        };

        let mut vars: HashMap<String, (Type, bool)> = HashMap::new();

        match self.advance() {
            Token::Identifier(_) => {}
            Token::KwFn => {
                if coroutine {
                    self.error_tip(
                        "Expected function name.",
                        "The `fn` keyword is not required after `async`.",
                    )
                } else {
                    self.error("Expected function name.")
                }
            }
            Token::KwAsync => {
                if !coroutine {
                    self.error_tip(
                        "Expected function name.",
                        &format!(
                            "If you want to make an async function, use {} the `async` keyword.",
                            "only".bold()
                        ),
                    )
                } else {
                    self.error("Expected function name.")
                }
            }
            _ => self.error("Expected function name."),
        }

        let name = self.current.extract();
        let mut params: Vec<FnParam> = vec![];

        self.expect_handle(Token::LeftParen, true, "Expected '(' after function name.");
        self.advance();

        while self.current != Token::RightParen {
            match &self.current {
                Token::Identifier(_) | Token::KwMut => {
                    let (name, mutable) = match self.current.clone() {
                        Token::Identifier(iden) => (iden, false),
                        Token::KwMut => {
                            self.advance();
                            (self.current.extract(), true)
                        }
                        _ => panic!(),
                    };

                    let param = match self.advance() {
                        Token::Colon => {
                            self.advance();
                            let annotation = self.parse_type();

                            FnParam {
                                name,
                                mutable,
                                annotation,
                            }
                        }
                        _ => self.error("Expected argument type."),
                    };

                    params.push(param.clone());
                    vars.insert(param.name, (param.annotation, param.mutable));
                }
                Token::RightParen => break,
                Token::Comma => {
                    self.advance();
                }
                _ => self.error("Expected either `mut` or identifier."),
            }
        }

        self.advance();
        let mut return_annotation = Type::None;

        match self.current {
            Token::Colon => {
                self.advance();
                return_annotation = self.parse_type();

                if self.current != Token::LeftCurly {
                    self.error("Expected '{' after function definition.")
                }
            }
            Token::LeftCurly => {}
            _ => self.error("Expected '{' after function definition."),
        }

        self.advance();
        let mut function: Vec<Node> = vec![];

        while self.current != Token::RightCurly {
            function.push(self.statement(false));
        }

        self.advance();

        Node::Function {
            name,
            params,
            function,
            return_annotation,
            coroutine,
            public,
        }
    }

    fn statement(&mut self, toplevel: bool) -> Node {
        match self.current {
            Token::KwLet => self.variable_decleration(false),
            Token::KwMut => {
                self.error_tip("Unexpected keyword.", "Use `let` to define a variable.")
            }
            Token::KwPub => match self.advance() {
                Token::KwLet => self.variable_decleration(true),
                Token::KwFn | Token::KwAsync => {
                    if toplevel {
                        self.function_decleration(true)
                    } else {
                        self.error("Functions cannot be defined inside other functions.")
                    }
                }
                Token::KwMut => self.error_tip(
                    "Expected variable decleration.",
                    "Change this to `pub let mut ...`",
                ),
                _ => self.error_tip(
                    "Expected variable decleration.",
                    "`pub` must be followed by `let`.",
                ),
            },
            Token::Identifier(_) => {
                /*  Lines that start with identifiers can either be assignments or expressions.
                    Therefore, we parse an expression, and if expression is a sole identifier and
                        the next token is a '=', it's an assignment.
                */
                let node = self.expression();

                match &node {
                    Node::Value(Value::Identifier(iden)) => {
                        if self.current == Token::Assign {
                            self.variable_assignment(iden.to_string())
                        } else {
                            node
                        }
                    }
                    _ => node,
                }
            }
            Token::KwFn | Token::KwAsync => {
                if toplevel {
                    self.function_decleration(false)
                } else {
                    self.error("Functions cannot be defined inside other functions.")
                }
            }
            Token::KwReturn => {
                if !toplevel {
                    self.return_statement()
                } else {
                    self.error_tip(
                        "Return statements can only be used inside functions.",
                        "Use the `exit!` builtin if you want to terminate the program.",
                    )
                }
            }
            Token::KwWhile => self.while_statement(),
            token_value!() => self.expression(),
            _ => self.error("Unexpected token."),
        }
    }

    pub fn parse(&mut self) {
        // let mut vars: HashMap<String, (Type, bool)> = HashMap::new();

        while self.current != Token::End {
            let statement = self.statement(true);
            self.ast.push(statement);
        }
    }
}
